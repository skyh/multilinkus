var inherits = require('js/inherits');
var Resource = require('mtl/core/Resource');
var Box = require('./Box');
var Match = require('./Match');


module.exports = Matcher;


function Matcher() {
	this.links_ = document.getElementsByTagName('a');
	Resource.call(this);
}


inherits(Matcher, Resource);


Matcher.INTERSECTION = 0;
Matcher.BOUNDING = 1;

Matcher.prototype.links_ = null;

Matcher.prototype.match = function (box, mode) {
	var links = this.links_;
	mode = mode || Matcher.INTERSECTION;

	switch (mode) {
		case Matcher.INTERSECTION:
			return queryIntersectionElements(links, box);
		case Matcher.BOUNDING:
			return queryBoundingElements(links, box);
		default:
			throw new Error('Bad match mode.');
	}
};

function queryIntersectionElements(elements, box) {
	var result = [];

	for (var i = elements.length; i--;) {
		var element = elements[i];

		if (!element.offsetParent) {
			//TODO: fix me for position:fixed
			continue;
		}

		var rects = element.getClientRects();
		var match = null;

		for (var j = rects.length; j--;) {
			var rectBox = Box.fromCSSRect(rects[j]);
			if (box.intersects(rectBox)) {
				if (!match) {
					match = new Match(element);
				}

				match.pushBox(rectBox);
			}
		}

		if (match) {
			result.push(match);
		}
	}

	return result;
}

function queryBoundingElements(elements, box) {
	var result = [];

	for (var i = elements.length; i--;) {
		var element = elements[i];

		if (!element.offsetParent) {
			//TODO: fix me for position:fixed
			continue;
		}

		var rects = element.getClientRects();
		var match = null;

		for (var j = rects.length; j--;) {
			var rectBox = Box.fromCSSRect(rects[j]);
			if (box.contains(rectBox)) {
				if (!match) {
					match = new Match(element);
				}

				match.pushBox(rectBox);
			}
		}

		if (match) {
			result.push(match);
		}
	}

	return result;
}
